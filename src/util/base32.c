#include "base32.h"
#include <string.h>

// RFC 4648 Base32 alphabet
static const char BASE32_ALPHABET[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

// Lookup table for decoding (maps ASCII to 5-bit values)
static const uint8_t BASE32_DECODE_TABLE[256] = {
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 0-7
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 8-15
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 16-23
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 24-31
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 32-39
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 40-47
    0xFF, 0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, // 48-55 ('2'-'7')
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 56-63
    0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, // 64-71 ('A'-'G')
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, // 72-79 ('H'-'O')
    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, // 80-87 ('P'-'W')
    0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 88-95 ('X'-'Z')
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 96-103
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 104-111
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 112-119
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 120-127
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 128-135
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 136-143
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 144-151
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 152-159
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 160-167
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 168-175
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 176-183
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 184-191
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 192-199
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 200-207
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 208-215
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 216-223
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 224-231
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 232-239
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 240-247
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  // 248-255
};

char* base32_encode(const uint8_t* input, size_t size) {
    if (input == NULL || size == 0) {
        return NULL;
    }
    
    // Calculate output size: each 5 bytes becomes 8 characters
    size_t output_len = ((size + 4) / 5) * 8;
    char* output = (char*)malloc(output_len + 1);
    if (output == NULL) {
        return NULL;
    }
    
    size_t out_idx = 0;
    size_t i;
    
    for (i = 0; i < size; i += 5) {
        uint64_t buffer = 0;
        size_t bytes_left = size - i;
        size_t bytes_to_read = bytes_left < 5 ? bytes_left : 5;
        
        // Pack bytes into buffer (big-endian)
        for (size_t j = 0; j < bytes_to_read; j++) {
            buffer |= ((uint64_t)input[i + j]) << ((4 - j) * 8);
        }
        
        // Extract 5-bit groups and encode
        size_t chars_to_write = (bytes_to_read * 8 + 4) / 5;
        for (size_t j = 0; j < chars_to_write; j++) {
            uint8_t index = (buffer >> (35 - j * 5)) & 0x1F;
            output[out_idx++] = BASE32_ALPHABET[index];
        }
        
        // Add padding
        size_t padding = 8 - chars_to_write;
        for (size_t j = 0; j < padding; j++) {
            output[out_idx++] = '=';
        }
    }
    
    output[out_idx] = '\0';
    return output;
}

uint8_t* base32_decode(const char* input, size_t* size) {
    if (input == NULL || size == NULL) {
        return NULL;
    }
    
    size_t input_len = strlen(input);
    if (input_len == 0 || input_len % 8 != 0) {
        *size = 0;
        return NULL;
    }
    
    // Remove padding to count actual characters
    size_t actual_chars = input_len;
    while (actual_chars > 0 && input[actual_chars - 1] == '=') {
        actual_chars--;
    }
    
    // Calculate output size
    size_t output_len = (actual_chars * 5) / 8;
    uint8_t* output = (uint8_t*)malloc(output_len);
    if (output == NULL) {
        *size = 0;
        return NULL;
    }
    
    size_t out_idx = 0;
    uint64_t buffer = 0;
    int bits_in_buffer = 0;
    
    for (size_t i = 0; i < actual_chars; i++) {
        uint8_t decoded = BASE32_DECODE_TABLE[(unsigned char)input[i]];
        if (decoded == 0xFF) {
            // Invalid character
            free(output);
            *size = 0;
            return NULL;
        }
        
        buffer = (buffer << 5) | decoded;
        bits_in_buffer += 5;
        
        if (bits_in_buffer >= 8) {
            bits_in_buffer -= 8;
            output[out_idx++] = (buffer >> bits_in_buffer) & 0xFF;
        }
    }
    
    *size = out_idx;
    return output;
}
